<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link type="text/css"  rel="stylesheet" href="../../css/dom.css"/>
	<script type="text/javascript" src="../../javascript/components/google-code-prettify/prettify.js"></script>
	<script type="text/javascript" src="../../javascript/components/google-code-prettify/util.js"></script>
	<link rel="stylesheet" href="../../javascript/components/google-code-prettify/prettify.css" type="text/css"/>
	<script type="text/javascript" src="../../javascript/core/domUtil.js"></script>
	<script type="text/javascript">
		function init(){
			PR.prettyPrint();
		}
	</script>
</head>
<body onload="init();">
	<div id="title" class="titleDiv">
		99.6、允许跨域的解决方案
	</div>
	<div class="tabTitleDiv">一、后台方案</div>
	<div class="tabTitleLine"></div>
	<div class="contentDiv">
		<div class="subTitleDiv addArrow">1/2、新增一个Filter类，在报文头中允许所有的Origin请求，代码如下</div>
		<pre class="prettyprint lang-java" id="codeShow1" style="font-weight:bold;color:#3f7f5f;">
package com.yourdomain.web.filter;
import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;
public class CorsFilter implements Filter {
	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
		HttpServletResponse response = (HttpServletResponse) res;
		response.setHeader("Access-Control-Allow-Origin", "*");
		response.setHeader("Access-Control-Allow-Headers", "*");//Origin, X-Requested-With, Content-Type, Accept
		chain.doFilter(req, res);
	}
	@Override
	public void init(FilterConfig filterConfig) {
	}
	@Override
	public void destroy() {
	}
}
		</pre>
		<div class="subTitleDiv addArrow">2/2、将新增的Filter注册到web容器中，spring-boot中注册的代码如下：</div>
		<pre class="prettyprint lang-java" id="codeShow1" style="font-weight:bold;color:#3f7f5f;">
package com.yourdomain.config;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.youdomain.web.CorsFilter;
@Configuration
public class FilterConfig {
	@Bean
	public FilterRegistrationBean&lt;CorsFilter&gt; corsFilter() {
		FilterRegistrationBean&lt;CorsFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;();
		registrationBean.setFilter(new CorsFilter());
		registrationBean.addUrlPatterns("/*");
		return registrationBean;
	}
}
		</pre>
	</div>
	
	<div class="tabTitleDiv">二、nginx配置方案</div>
	<div class="tabTitleLine"></div>
	<div class="contentDiv">
		<div class="subTitleDiv addArrow">
			浏览器跨域访问的策略：先对跨域地址发起一个OPTIONS类型的请求，当得到回复码204且报文头里是Access-Control-Allow-Origin:*时，才发起正式请求，因此，对于OPTIONS类型的请求不需要转发到后台，直接在ngixn中答复浏览器即可，配置样例如下：
			<pre class="prettyprint lang-properties" id="codeShow1" style="font-weight:bold;color:#3f7f5f;">
server {
	listen 443 ssl;
	server_name  xxxx.com;
	#...此处省略非关键性内容...
	location / {
		if ($request_method = 'OPTIONS') {
			# 对于OPTIONS，不保存请求日志到日志文件
			access_log off;
			# 这里配置允许跨域的域名，* 代表所有，也可以写域名：http://www.xxx.com 或者IP+端口 http://192.168.1.10
			add_header 'Access-Control-Allow-Origin' '*';
			# 允许的请求类型
			add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';
			add_header 'Access-Control-Allow-Credentials' true;
			add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
			# 允许跨域的最大时间，超过这个时间又会重发一次OPTIONS请求获取新的认证
			add_header 'Access-Control-Max-Age' 1728000;
			add_header 'Content-Type' 'text/plain charset=UTF-8';
			add_header 'Content-Length' 0;
			# 直接在这里返回204响应，不转发到后台服务程序
			return 204;
		}
		root /your-html-root-folder/;
		index index.html;
		proxy_pass		http://yourip:yourport/backend-project/
		#proxy_set_header	Host			 $host; #保留代理之前的host
		proxy_set_header	X-Real-IP		$remote_addr; #保留代理之前的真实客户端ip, 如果使用了CDN产品, 则是CDN节点IP
		proxy_set_header	X-Forwarded-For  $proxy_add_x_forwarded_for;
		proxy_set_header	HTTP_X_FORWARDED_FOR $remote_addr; #在多级代理的情况下，记录每次代理之前的客户端真实ip
		add_header 'Access-Control-Allow-Origin' '*'; #允许来自所有的访问地址
		add_header 'Access-Control-Allow-Methods' 'POST'; #支持的请求方式
		add_header 'Access-Control-Allow-Header' 'Content-Type,*'; #支持的媒体类型
	}
}
			</pre>
		</div>
	</div>
</body>
</html>